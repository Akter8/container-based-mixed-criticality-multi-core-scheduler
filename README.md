# Container-based Mixed-Criticality Real-time Scheduling for Multi-core Systems

Simulates a 4-level container based MCS+RTS scheduler for a multi-core platform.

## Description of files

* configuration.h - Contains the configuration settings of the program.
* job.h - Contains the ADT of Job.
* job.c - Contains the function definitions of a job.
* container.h - Contains the ADT of a container.
* container.c - Contains the functions of a container.
* processor.h - Containers the ADT of the processor with two non-global containers.
* processor.c - Containers the functions of a processor.
* cpu.h - Contains the ADT of cpu with multiple processors and two global-containers.
* cpu.c - Contains the functions of the cpu.
* driver.c - Contains the driver code of the program.
* priority_queue.h - Contains the ADT for the priority queue used for scheduling.
* priority_queue.c - Contains the functions used to control the priority queue data structure.
* scheduler.h - Contains the functions used to schedule the task set.
* scheduler.c - Contains function definitions of the main scheduler.

## Description of program structure

* Every container has its own set of jobs that are encapsulated in the container ADT.
* Every processor has two container (level-A and level-B) which are local to the particular processor.
* The cpu has multiple processor (each containing its own level-A and level-B containers) and two global containers (level-C and level-D).
* The jobs are added to the corresponding ready queue (each processor has its own ready queue) along with a global ready queue for the lower criticality tasks.
* The jobs are scheduled till the upcoming decision point, which could be a job entering the system or a job finishing its processor time.
* There are mechanisms in place for the system to increase its criticality (done using rand() function) and also reduce the criticality as and when required. This happens at the time of adding a job into the ready queue where the jobs actual execution time is also calculated.

## To do

* Slack stealing has not implemented. Most of the data structure required for this is in place. But the data structures still need to be tweaked a bit before slack stealing can be implemented.
* Extensive testing has not been done due to time constraints.
* A task-based model has not been implemented, currently a job-based model has been implemeted. The data structures required for this change are in place and will be a easy switch.
* Calculation of response and finishing time for all tasks to find the performance of the program.

## How to run the program

* Make the required changes in the configuration.h file.
* Make the required changes in the Makefile (compiler and flags).
* Run the command "make" on the terminal. Then run the executable (called "run" by default).
* The output file ("output.txt" by default) contains the output generated by the program.
* Run "make clean" to remove all the compilation and the files generated by running the program.
